package user

import (
	"MusicBot/user/playList"
	"MusicBot/user/utils"
	"fmt"
	"github.com/mymmrac/telego"
	"github.com/mymmrac/telego/telegoutil"
	"github.com/withmandala/go-log"
)

type hostUser struct {
	userFather
	pass          string
	connectedUser map[utils.UserID]*sendingUser
	playList      playList.PlayList
}

func (h *hostUser) init(tg Bot, logger *log.Logger, chatID utils.UserID) {
	h.fatherInit(tg, logger, chatID)

	h.pass = "test pass"
	h.connectedUser = make(map[utils.UserID]*sendingUser)
	h.playList.Init()
	h.sendText("–¢—ã –ø—Ä–∏–Ω–∏–º–∞–µ—à—å —Ç—Ä–µ–∫–∏üëç –ï—Å–ª–∏ —á—Ç–æ, –µ—Å—Ç—å –∫–æ–º–∞–Ω–¥–∞ /menu", false)
	h.sendText("–û—Ç–ø—Ä–∞–≤—å —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–µ–º –∫—Ç–æ —Ö–æ—á–µ—Ç –ø—Ä–∏—Å–æ–µ–¥–µ–Ω–∏—Ç—å—Å—è‚§µÔ∏è", false)
	h.sendText(fmt.Sprintf("<code>secretMessage/@%v/%v</code>", h.id.ChatID.Username, h.pass), false)
}

func (h *hostUser) handler(update *telego.Update) (user users, needInit bool) {
	if update.Message != nil {
		switch update.Message.Text {
		case "/menu":
			h.sendMenu()
		case "/start":
			h.out()
			return &unregUser{}, true
		}
	}
	if update.CallbackQuery != nil {
		switch update.CallbackQuery.Data {
		case "getTracks":
			h.sendAudioPack()
		case "getSummary":
			h.sendSummary()
		case "sendNotify":
			h.sendNotify()
		}
		_ = h.tg.AnswerCallbackQuery(
			&telego.AnswerCallbackQueryParams{CallbackQueryID: update.CallbackQuery.ID})
	}
	return h, false
}

func (h *hostUser) sendMenu() {
	text := "–ú–µ–Ω—éüéõ"
	keyboard := telegoutil.InlineKeyboard(
		telegoutil.InlineKeyboardRow(
			telegoutil.InlineKeyboardButton("–Ω–æ–≤–∞—è –ø–æ—Ä—Ü–∏—è üéß").WithCallbackData("getTracks"),
		),
		telegoutil.InlineKeyboardRow(
			telegoutil.InlineKeyboardButton("–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ üéß —É üë§").WithCallbackData("getSummary"),
		),
		telegoutil.InlineKeyboardRow(
			telegoutil.InlineKeyboardButton("–æ–ø–æ–≤–µ—Å—Ç–∏—Ç—å üë§ —É –∫–æ—Ç–æ—Ä—ã—Ö –º–∞–ª–æ üéß").WithCallbackData("sendNotify"),
		),
	)
	h.sendMessage(telegoutil.Message(h.id.ChatID, text).WithReplyMarkup(keyboard), false)
}

func (h *hostUser) sendAudioPack() (sentMsgs []*telego.Message) {
	audios, _ := h.playList.GetAudio()
	for _, audio := range audios {
		msg := h.sendAudio(audio)
		if msg != nil {
			sentMsgs = append(sentMsgs, msg)
		}
	}
	return sentMsgs
}

func (h *hostUser) sendNotify() (sentMsg *telego.Message) {
	summary := h.playList.GetSummary()
	if len(summary) == 0 {
		return h.sendText("–ù–∏–∫—Ç–æ –µ—â–µ –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è", false)
	}
	for _, sum := range summary {
		if sum.Num < 2 {
			h.connectedUser[sum.ID].tracksEndedInQueue()
		}
	}
	return h.sendText("–û—Ç–ø—Ä–∞–≤–∏–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Ç–µ–º —É –∫–æ–≥–æ 1 –∏–ª–∏ 0 —Ç—Ä–µ–∫–æ–≤", false)
}

func (h *hostUser) sendSummary() (sentMsg *telego.Message) {
	text := "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–µ–∫–æ–≤ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n\n"
	summary := h.playList.GetSummary()
	if len(summary) == 0 {
		return h.sendText("–ù–∏–∫—Ç–æ –µ—â–µ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–æ–±–∞–≤–∏–ª", false)
	}
	for _, s := range summary {
		text += utils.UserNameInserting("", s.ID, fmt.Sprintf("(%v)", s.Num))
	}
	return h.sendText(text, false)
}

func (h *hostUser) validatePass(pass string) (ok bool) {
	if pass == h.pass {
		return true
	} else {
		return false
	}
}

func (h *hostUser) join(user *sendingUser) (sentMsg *telego.Message) {
	h.connectedUser[user.id] = user
	sentMsg = h.sendText(utils.UserNameInserting("–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è ", user.id, ""), false)
	return
}

func (h *hostUser) disconnectUser(user *sendingUser) (sentMsg *telego.Message) {
	delete(h.connectedUser, user.id)
	sentMsg = h.sendText(utils.UserNameInserting("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ", user.id, " –æ—Ç–∫–ª—é—á–∏–ª—Å—è"), false)
	return
}

func (h *hostUser) setAudio(from *sendingUser, audio *telego.SendAudioParams) (sentMsg *telego.Message, err error) {
	audio.ChatID = h.id.ChatID
	err = h.playList.SetAudio(from.id, audio)
	if err != nil {
		return
	}
	sentMsg = h.sendText(utils.UserNameInserting(
		"",
		from.id,
		" –¥–æ–±–∞–≤–∏–ª –≤ –æ—á–µ—Ä–µ–¥—å —Ç—Ä–µ–∫: \""+audio.Title+"\""),
		false)
	return
}

func (h *hostUser) out() {
	for _, user := range h.connectedUser {
		user.hostOut()
	}
	h.sendText("–¢—ã –≤—ã—à–µ–ª –∏–∑ —Ä–æ–ª–∏", false)
}

func (h *hostUser) trackNum(who utils.UserID) int {
	return h.playList.UserTrackNum(who)
}
